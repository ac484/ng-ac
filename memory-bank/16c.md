# 合約管理功能實現規劃 (C7)

## 目標
實現基於 @angular/fire 與 Firestore 的合約管理功能，遵循專案 DDD 架構與極簡主義理念。

## 核心原則
- **極簡主義**: 每個文件只包含必要的功能，避免無意義的膨脹
- **DDD 架構**: 嚴格遵循領域驅動設計的分層架構
- **單一職責**: 每個類別/文件只負責一個明確的職責
- **代碼復用**: 最大化利用現有基礎設施，避免重複實現

## 文件樹狀圖

```
src/app/
├── application/
│   ├── commands/contracts/
│   │   ├── create-contract.command.ts      # 創建合約命令
│   │   ├── update-contract.command.ts      # 更新合約命令
│   │   ├── delete-contract.command.ts      # 刪除合約命令
│   │   └── index.ts                        # 命令匯出
│   ├── dto/contracts/
│   │   ├── contract.dto.ts                 # 合約 DTO
│   │   ├── contract-create.dto.ts          # 創建合約 DTO
│   │   ├── contract-update.dto.ts          # 更新合約 DTO
│   │   └── index.ts                        # DTO 匯出
│   ├── services/contracts/
│   │   ├── contract-application.service.ts # 合約應用服務
│   │   └── index.ts                        # 服務匯出
│   └── use-cases/contracts/
│       ├── create-contract.use-case.ts     # 創建合約用例
│       ├── update-contract.use-case.ts     # 更新合約用例
│       ├── delete-contract.use-case.ts     # 刪除合約用例
│       └── index.ts                        # 用例匯出
├── domain/
│   ├── entities/contracts/
│   │   ├── contract.entity.ts              # 合約實體
│   │   ├── contract-status.vo.ts           # 合約狀態值對象
│   │   ├── contract-type.vo.ts             # 合約類型值對象
│   │   └── index.ts                        # 實體匯出
│   ├── repositories/contracts/
│   │   ├── contract.repository.interface.ts # 合約倉儲接口
│   │   └── index.ts                        # 倉儲匯出
│   └── services/contracts/
│       ├── contract-domain.service.ts      # 合約領域服務
│       └── index.ts                        # 服務匯出
├── infrastructure/
│   └── persistence/repositories/contracts/
│       ├── contract.firestore.repository.ts # Firestore 合約倉儲實現
│       └── index.ts                        # 倉儲實現匯出
└── interface/
    ├── components/contracts/
    │   ├── contract-form/
    │   │   ├── contract-form.component.ts  # 合約表單組件
    │   │   ├── contract-form.component.scss
    │   │   └── index.ts
    │   ├── contract-list/
    │   │   ├── contract-list.component.ts  # 合約列表組件
    │   │   ├── contract-list.component.scss
    │   │   └── index.ts
    │   └── index.ts                        # 組件匯出
    └── pages/contracts/
        ├── contract-detail/
        │   ├── contract-detail.page.ts      # 合約詳情頁面
        │   └── index.ts
        ├── contract-management/
        │   ├── contract-management.page.ts  # 合約管理頁面
        │   └── index.ts
        └── index.ts                         # 頁面匯出
```

## 實現策略

### 1. 領域層優先 (Domain-First)
- 先實現合約實體和值對象
- 定義清晰的業務規則和約束
- 使用現有的 BaseEntity 和 Result 模式

### 2. 基礎設施實現
- 利用現有的 Firebase 基礎設施
- 繼承現有的 Firebase 倉儲基類
- 最小化重複代碼

### 3. 應用層編排
- 服務只負責協調，不包含業務邏輯
- 使用現有的命令/查詢模式
- 保持服務的輕量化

### 4. 接口層實現
- 組件只負責 UI 邏輯
- 使用現有的 Material 組件庫
- 遵循現有的組件命名規範

## 文件大小控制策略

### 實體文件
- **目標**: 每個實體文件 < 100 行
- **策略**: 只包含核心業務邏輯，複雜邏輯委託給領域服務

### 服務文件
- **目標**: 每個服務文件 < 150 行
- **策略**: 使用組合而非繼承，避免單一文件過於複雜

### 組件文件
- **目標**: 每個組件文件 < 200 行
- **策略**: 將複雜邏輯提取到服務中，組件只負責綁定

### 倉儲文件
- **目標**: 每個倉儲文件 < 120 行
- **策略**: 繼承現有基類，只實現特定邏輯

## 依賴關係

```
Interface → Application → Domain
Infrastructure → Domain
Shared → 所有層級
```

## 實現順序

1. **Phase 1**: 領域層 (Domain Layer)
   - 合約實體和值對象
   - 倉儲接口
   - 領域服務

2. **Phase 2**: 基礎設施層 (Infrastructure Layer)
   - Firestore 倉儲實現
   - 數據映射

3. **Phase 3**: 應用層 (Application Layer)
   - 命令和用例
   - 應用服務

4. **Phase 4**: 接口層 (Interface Layer)
   - 組件實現
   - 頁面實現

## 質量保證

- 每個文件都有明確的職責邊界
- 使用現有的測試框架進行測試
- 遵循現有的代碼風格指南
- 定期檢查文件大小，防止膨脹

## 風險控制

- **文件膨脹風險**: 定期檢查文件行數，超過目標時重構
- **架構偏離風險**: 每階段完成後進行架構審查
- **重複代碼風險**: 使用現有基礎設施，避免重複實現