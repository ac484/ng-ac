# Angular DDD 核心庫使用指南

## 📚 **概述**

本指南介紹如何在 Angular 專案中使用 `@type-ddd/core` 和 `rich-domain` 庫來實現 Domain-Driven Design (DDD) 架構。

## 🚀 **安裝**

### 安裝核心依賴

```bash
# 使用 yarn
yarn add @type-ddd/core rich-domain

# 使用 pnpm
pnpm add @type-ddd/core rich-domain
```

### 安裝特定模組（可選）

```bash
# 安裝特定 DDD 模組
npm install @type-ddd/email @type-ddd/money @type-ddd/date @type-ddd/password

# 安裝驗證相關
npm install @type-ddd/cpf @type-ddd/cnpj @type-ddd/username @type-ddd/zip-code
```

## 🏗️ **核心概念**

### 1. **Result 模式**
```typescript
import { Result, Ok, Fail } from '@type-ddd/core';

// 成功結果
const successResult: Result<string> = Ok('操作成功');

// 失敗結果
const failureResult: Result<string> = Fail('操作失敗');

// 檢查結果
if (successResult.isOk()) {
  console.log('成功:', successResult.value());
} else {
  console.log('失敗:', successResult.error());
}
```

### 2. **Value Object（值物件）**
```typescript
import { ValueObject, Ok, Fail, Result } from '@type-ddd/core';

interface EmailProps {
  value: string;
}

export class Email extends ValueObject<EmailProps> {
  private constructor(props: EmailProps) {
    super(props);
  }

  // 靜態驗證方法
  public static isValidProps({ value }: EmailProps): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  }

  // 靜態工廠方法
  public static create(value: string): Result<Email> {
    if (!this.isValidProps({ value })) {
      return Fail('無效的電子郵件格式');
    }
    return Ok(new Email({ value }));
  }

  // 業務邏輯方法
  public getDomain(): string {
    return this.props.value.split('@')[1];
  }

  public getLocalPart(): string {
    return this.props.value.split('@')[0];
  }
}
```

### 3. **Entity（實體）**
```typescript
import { Entity, Ok, Fail, Result, UID } from '@type-ddd/core';

interface UserProps {
  id?: UID;
  email: Email;
  name: string;
  isActive: boolean;
}

export class User extends Entity<UserProps> {
  private constructor(props: UserProps) {
    super(props);
  }

  // 靜態驗證方法
  public static isValidProps({ email, name }: UserProps): boolean {
    return email && name && name.trim().length > 0;
  }

  // 靜態工廠方法
  public static create(props: UserProps): Result<User> {
    if (!this.isValidProps(props)) {
      return Fail('無效的用戶資料');
    }
    return Ok(new User(props));
  }

  // 業務邏輯方法
  public activate(): User {
    this.props.isActive = true;
    return this;
  }

  public deactivate(): User {
    this.props.isActive = false;
    return this;
  }

  public changeName(newName: string): User {
    if (newName.trim().length > 0) {
      this.props.name = newName.trim();
    }
    return this;
  }
}
```

### 4. **Aggregate（聚合根）**
```typescript
import { Aggregate, Ok, Fail, Result, UID, EventHandler } from '@type-ddd/core';

interface OrderProps {
  id?: UID;
  userId: UID;
  items: OrderItem[];
  status: OrderStatus;
  totalAmount: Money;
}

export class Order extends Aggregate<OrderProps> {
  private constructor(props: OrderProps) {
    super(props);
  }

  // 靜態工廠方法
  public static create(props: OrderProps): Result<Order> {
    if (!this.isValidProps(props)) {
      return Fail('無效的訂單資料');
    }
    return Ok(new Order(props));
  }

  // 業務邏輯方法
  public addItem(item: OrderItem): Order {
    this.props.items.push(item);
    this.props.totalAmount = this.props.totalAmount.sum(item.price);

    // 添加領域事件
    this.addEvent(new OrderItemAddedEvent(this.props.id, item));

    return this;
  }

  public confirm(): Order {
    this.props.status = OrderStatus.CONFIRMED;
    this.addEvent(new OrderConfirmedEvent(this.props.id));
    return this;
  }

  public cancel(): Order {
    this.props.status = OrderStatus.CANCELLED;
    this.addEvent(new OrderCancelledEvent(this.props.id));
    return this;
  }
}
```

## 🔄 **領域事件處理**

### 1. **事件處理器**
```typescript
import { EventHandler } from '@type-ddd/core';

export class OrderConfirmedEvent extends EventHandler<Order> {
  constructor() {
    super({ eventName: 'ORDER_CONFIRMED' });
  }

  dispatch(order: Order): void {
    // 處理訂單確認邏輯
    console.log(`訂單 ${order.id} 已確認`);

    // 發送到全域事件總線
    order.context().dispatchEvent('NOTIFICATION:ORDER_CONFIRMED', {
      orderId: order.id,
      userId: order.props.userId
    });
  }
}
```

### 2. **全域事件管理**
```typescript
import { Context } from '@type-ddd/core';

// 創建全域事件上下文
const globalContext = Context.events();

// 訂閱事件
globalContext.subscribe('NOTIFICATION:ORDER_CONFIRMED', (event) => {
  const { orderId, userId } = event.detail[0];
  console.log(`發送確認通知給用戶 ${userId}`);
});

// 發送事件
globalContext.dispatchEvent('NOTIFICATION:ORDER_CONFIRMED', {
  orderId: 'order-123',
  userId: 'user-456'
});
```

## 📊 **Result 組合與驗證**

### 1. **組合多個 Result**
```typescript
import { Result, Ok, Fail } from '@type-ddd/core';

// 創建多個 Value Objects
const emailResult = Email.create('user@example.com');
const nameResult = Name.create('John Doe');
const ageResult = Age.create(25);

// 組合結果
const combinedResult = Result.combine([emailResult, nameResult, ageResult]);

if (combinedResult.isOk()) {
  // 所有驗證都通過
  const user = User.create({
    email: emailResult.value(),
    name: nameResult.value(),
    age: ageResult.value()
  });
} else {
  // 處理錯誤
  console.error('驗證失敗:', combinedResult.error());
}
```

### 2. **批量創建 Value Objects**
```typescript
import { ValueObject, Class } from '@type-ddd/core';

// 定義創建配置
const emailConfig = Class<EmailProps>(Email, { value: 'user@example.com' });
const nameConfig = Class<NameProps>(Name, { value: 'John Doe' });
const ageConfig = Class<AgeProps>(Age, { value: 25 });

// 批量創建
const { result, data } = ValueObject.createMany([emailConfig, nameConfig, ageConfig]);

if (result.isOk()) {
  // 獲取創建的實例
  const email = data.next().value() as Email;
  const name = data.next().value() as Name;
  const age = data.next().value() as Age;

  // 使用這些實例
  const user = User.create({ email, name, age });
} else {
  console.error('批量創建失敗:', result.error());
}
```

## 🎨 **Angular 整合**

### 1. **服務層整合**
```typescript
import { Injectable } from '@angular/core';
import { User } from '../domain/entities/user.entity';
import { UserRepository } from '../domain/repositories/user.repository';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  constructor(private userRepository: UserRepository) {}

  async createUser(email: string, name: string, age: number): Promise<Result<User>> {
    // 創建 Value Objects
    const emailResult = Email.create(email);
    const nameResult = Name.create(name);
    const ageResult = Age.create(age);

    // 組合結果
    const combinedResult = Result.combine([emailResult, nameResult, ageResult]);
    if (combinedResult.isFail()) {
      return Fail(combinedResult.error());
    }

    // 創建用戶實體
    const userResult = User.create({
      email: emailResult.value(),
      name: nameResult.value(),
      age: ageResult.value()
    });

    if (userResult.isFail()) {
      return Fail(userResult.error());
    }

    // 保存到資料庫
    const savedUser = await this.userRepository.save(userResult.value());
    return Ok(savedUser);
  }
}
```

### 2. **組件層整合**
```typescript
import { Component } from '@angular/core';
import { UserService } from '../services/user.service';
import { Result } from '@type-ddd/core';

@Component({
  selector: 'app-user-form',
  template: `
    <form (ngSubmit)="onSubmit()">
      <input [(ngModel)]="email" placeholder="Email" />
      <input [(ngModel)]="name" placeholder="Name" />
      <input [(ngModel)]="age" type="number" placeholder="Age" />
      <button type="submit">創建用戶</button>
    </form>

    <div *ngIf="error" class="error">{{ error }}</div>
    <div *ngIf="success" class="success">{{ success }}</div>
  `
})
export class UserFormComponent {
  email = '';
  name = '';
  age = 0;
  error = '';
  success = '';

  constructor(private userService: UserService) {}

  async onSubmit() {
    this.error = '';
    this.success = '';

    const result = await this.userService.createUser(this.email, this.name, this.age);

    if (result.isOk()) {
      this.success = '用戶創建成功！';
      this.resetForm();
    } else {
      this.error = result.error();
    }
  }

  private resetForm() {
    this.email = '';
    this.name = '';
    this.age = 0;
  }
}
```

## 🧪 **測試策略**

### 1. **Value Object 測試**
```typescript
import { Email } from './email.value-object';

describe('Email Value Object', () => {
  it('應該創建有效的電子郵件', () => {
    const result = Email.create('test@example.com');
    expect(result.isOk()).toBe(true);
    expect(result.value().get('value')).toBe('test@example.com');
  });

  it('應該拒絕無效的電子郵件', () => {
    const result = Email.create('invalid-email');
    expect(result.isFail()).toBe(true);
    expect(result.error()).toBe('無效的電子郵件格式');
  });

  it('應該正確提取域名', () => {
    const email = Email.create('user@example.com').value();
    expect(email.getDomain()).toBe('example.com');
  });
});
```

### 2. **Entity 測試**
```typescript
import { User } from './user.entity';
import { Email } from './email.value-object';

describe('User Entity', () => {
  it('應該創建有效的用戶', () => {
    const email = Email.create('test@example.com').value();
    const result = User.create({ email, name: 'John Doe', isActive: true });

    expect(result.isOk()).toBe(true);
    expect(result.value().props.name).toBe('John Doe');
  });

  it('應該能夠激活和停用用戶', () => {
    const email = Email.create('test@example.com').value();
    const user = User.create({ email, name: 'John Doe', isActive: false }).value();

    user.activate();
    expect(user.props.isActive).toBe(true);

    user.deactivate();
    expect(user.props.isActive).toBe(false);
  });
});
```

## 📁 **專案結構建議**

```
src/
├── app/
│   ├── domain/
│   │   ├── entities/
│   │   │   ├── user.entity.ts
│   │   │   └── order.entity.ts
│   │   ├── value-objects/
│   │   │   ├── email.vo.ts
│   │   │   └── money.vo.ts
│   │   ├── aggregates/
│   │   │   └── order.aggregate.ts
│   │   ├── repositories/
│   │   │   └── user.repository.ts
│   │   └── events/
│   │       └── order.events.ts
│   ├── application/
│   │   ├── services/
│   │   │   └── user.service.ts
│   │   └── use-cases/
│   │       └── create-user.use-case.ts
│   └── interface/
│       ├── components/
│       │   └── user-form/
│       └── pages/
│           └── user-list/
└── shared/
    ├── base/
    │   └── base.entity.ts
    └── utils/
        └── result.utils.ts
```

## 🔧 **最佳實踐**

### 1. **錯誤處理**
- 始終使用 `Result` 類型來處理成功/失敗情況
- 提供有意義的錯誤訊息
- 在應用層處理錯誤並轉換為用戶友好的訊息

### 2. **驗證**
- 在 Value Object 和 Entity 中實現靜態驗證方法
- 使用 `Result.combine` 來組合多個驗證結果
- 在創建實體之前驗證所有輸入

### 3. **事件驅動**
- 使用領域事件來解耦業務邏輯
- 在聚合根中添加和分發事件
- 使用全域事件總線進行跨邊界通信

### 4. **不可變性**
- Value Object 應該是不可變的
- 使用 `clone` 方法來創建實體的副本
- 避免直接修改實體的內部狀態

### 5. **測試**
- 為每個 Value Object 和 Entity 編寫測試
- 測試業務規則和驗證邏輯
- 使用測試驅動開發來設計領域模型

## 📖 **參考資源**

- [@type-ddd/core 官方文檔](https://github.com/4lessandrodev/type-ddd)
- [rich-domain 官方文檔](https://github.com/4lessandrodev/rich-domain)
- [Domain-Driven Design 官方網站](https://domainlanguage.com/)
- [Angular 官方文檔](https://angular.io/docs)

## 🚨 **常見問題**

### Q: 如何處理異步操作？
A: 使用 `async/await` 與 `Result` 類型結合：

```typescript
async function saveUser(user: User): Promise<Result<User>> {
  try {
    const savedUser = await this.repository.save(user);
    return Ok(savedUser);
  } catch (error) {
    return Fail(`保存用戶失敗: ${error.message}`);
  }
}
```

### Q: 如何處理複雜的業務規則？
A: 將複雜的業務邏輯封裝在 Entity 或 Aggregate 的方法中：

```typescript
public canCancel(): boolean {
  return this.props.status === OrderStatus.PENDING &&
         this.props.items.length > 0;
}

public cancel(): Result<Order> {
  if (!this.canCancel()) {
    return Fail('訂單無法取消');
  }

  this.props.status = OrderStatus.CANCELLED;
  this.addEvent(new OrderCancelledEvent(this.props.id));
  return Ok(this);
}
```

### Q: 如何處理跨聚合的業務邏輯？
A: 使用領域服務或應用服務來協調多個聚合：

```typescript
@Injectable()
export class OrderService {
  async processOrder(orderId: string, payment: Payment): Promise<Result<void>> {
    const order = await this.orderRepository.findById(orderId);
    const user = await this.userRepository.findById(order.props.userId);

    // 協調多個聚合的業務邏輯
    const result = await this.processOrderPayment(order, user, payment);
    return result;
  }
}
```
