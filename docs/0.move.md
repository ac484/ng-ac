## 0.move — 職責收斂與搬遷計畫（針對 `docs/0.TREE.md`）

### 目標
- **收斂分散職責**：統一 Guards/Interceptors、認證與應用層協作、`core` 邊界、`modules` 退場策略、`shared/material` 的示範性代碼。
- **強化一致性**：遵循 DDD 目錄邏輯與依賴方向，維持清晰邊界與可維護性（對齊 `src/app` DDD 結構約定）[[memory:5079044]].
- **認證單一真實來源（手搓精簡版）**：以自製輕量服務統一 token/會話存儲與校驗，避免多頭馬車與額外框架耦合。

### 原則
- **DDD 邊界優先**：
  - `interface`：視圖/路由/守衛等 UI 邏輯。
  - `application`：用例協作與流程編排（不做基礎實作）。
  - `domain`：業務規則與模型（無框架依賴）。
  - `infrastructure`：框架/外部服務適配（HTTP、Firebase、日誌、攔截器）。
  - `shared`：跨層通用工具與原子組件（避免業務耦合）。
- **Standalone 優先**：以 `app.routes.ts` 與 `provide*` 為核心，`modules/` 僅保留必要聚合或逐步退場。
- **最小可行變更**：優先完成可分批上線的穩妥搬遷，配套自動化更新匯入與驗證。

### 範圍
- `src/app/core/*`, `src/app/infrastructure/*`, `src/app/interface/*`, `src/app/security/*`, `src/app/application/*`, `src/app/shared/*`, `src/app/modules/*`。

## 分階段計畫

### Phase 0 — 基線與自動化
- 建立腳本（不立即提交代碼，先規劃）：
  - `tools/scripts/generate-tree.ts`：從檔案系統自動產生 `docs/0.TREE.md`，避免手動漂移。
  - `tools/scripts/rename-imports.ts`：使用 TypeScript AST（`ts-morph`）自動修正匯入路徑。
- 在每個 DDD 頂層目錄新增極短 `README.md`（層責 3–5 條守則）。
- 輸出影響清單與估時，於 PR 模板中要求貼上對應 Phase 的驗收項。

### Phase 1 — Guards / Interceptors 統一歸屬
- 規則：
  - 路由/頁面層守衛 → `interface/guards`。
  - HTTP/錯誤/日誌攔截器 → `infrastructure/interceptors`。
  - `core` 僅做「提供者聚合」與啟動配置，不持有具體守衛/攔截器實現。
- 計畫搬遷（目錄層級）：
  - `src/app/core/guards.ts` → 合併為 `interface/guards` 下具體守衛，或改為 `core/services.ts` 僅匯出 providers。
  - `src/app/core/interceptors.ts`、`src/app/core/net/default.interceptor.ts` → `infrastructure/interceptors/*`（`auth.interceptor.ts`、`error.interceptor.ts`、`logging.interceptor.ts` 已存在則統一註冊）。
  - `src/app/security/authorization/guards/*` → 若為路由守衛，移至 `interface/guards`；若非路由型檢查，視情況沉入 `application` 或 `infrastructure`。
- 配套修改：
  - `app.config.ts`：統一於此註冊 HTTP 攔截器與守衛 provider。
  - `app.routes.ts`：引用 `interface/guards` 中的守衛。
- 驗收標準：
  - 專案中僅有一處來源宣告每類攔截器鏈。
  - `interface/guards` 成為唯一路由守衛來源。
  - `core` 無具體守衛/攔截器實作。

### Phase 2 — 認證/授權收斂（手搓精簡版）
- 邏輯分工：
  - `domain/services/auth.domain.service.ts`：純業務規則與授權判斷（角色/權限/規格）。
  - `infrastructure/security`：實作輕量 token 與會話策略，例如：
    - `token-storage.service.ts`（localStorage/IndexedDB/Memory，附命名空間與版本），
    - `auth-http.interceptor.ts`（自動附掛 Authorization header、處理 401/403），
    - `refresh-token.service.ts`（可移自 `core/net`）。
  - `infrastructure/persistence/firebase/firebase-auth.service.ts`：Firebase 適配層，與自製 token 策略對接（不依賴外部框架封裝）。
  - `application/use-cases/login.use-case.ts`、`register.use-case.ts`：協作流程編排（調用 infra 與 domain 校驗）。
  - 可選 Facade：`application/services/auth.facade.ts`，抽象 UI 入口，避免 `interface` 觸及 infra。
- 整理與搬遷：
  - `src/app/security/authentication/services/*`：
    - 純 UI/路由相關 → `interface/guards` 或 `interface/controllers`。
    - 第三方/框架整合 → `infrastructure/*`（如 `security` 或 `persistence/firebase` 分類）。
  - 確保所有流程透過「自製 token/會話服務」實現統一存儲/校驗/刷新；移除重複且分散的 token 邏輯。
- 驗收標準：
  - 單一 Facade/UseCase 為 UI 的唯一入口。
  - Infra 對外只提供介面適配，無應用流程控制。
  - 任何認證與 token 使用均由「自製 token/會話服務」統一管理。

### Phase 3 — Standalone 化與 `modules/` 退場
- 盤點 `src/app/modules/*`：
  - 若僅作為路由/提供者聚合，改為對應的 `provide*` 工具函式或 barrel。
  - 逐步移除 `auth.module.ts`、`user.module.ts` 等，如有必要保留，轉為單一 `index.ts` 匯出聚合。
- 驗收標準：
  - `app` 能完全依賴 Standalone 組件與 `app.routes.ts` 運作。
  - 移除或最小化 `modules/` 的耦合。

### Phase 4 — `shared/components/material` 精簡
- 目標：將示範/不常用包裝元件遷移至 `docs/playground` 或 `labs/material-demo`。
- 保留：跨 domain 可重用的原子級或版型級元件。
- 驗收標準：
  - `shared/components/material/*` 僅保留實際被多處引用且穩定的元件。
  - Demo/教學類內容與生產代碼分離。

### Phase 5 — `core` 邊界調整
- 內容：
  - 保留：啟動流程、全域初始化（如 `startup.service.ts`）、最低限度 providers 聚合。
  - 重新定位：
    - `core/net/refresh-token.service.ts` → `infrastructure/interceptors` 或 `infrastructure/security/token-refresh.service.ts`。
    - `core/i18n`：若屬外部適配（載入翻譯資源/HTTP），可轉至 `infrastructure/i18n`；若屬 UI 層翻譯使用，可於 `interface` 提供輕薄封裝。
- 驗收標準：
  - `core` 不持有具體業務或外部整合實作。

## 具體搬遷對照表（摘要）

| 類別 | 來源 | 目的 | 動作 | 備註 |
|---|---|---|---|---|
| 路由守衛 | `core/guards.ts` | `interface/guards/*` | 分拆/移動 | `core` 僅保留 providers 聚合 |
| 攔截器 | `core/interceptors.ts`、`core/net/default.interceptor.ts` | `infrastructure/interceptors/*` | 移動/合併 | 於 `app.config.ts` 統一註冊 |
| 授權守衛 | `security/authorization/guards/*` | `interface/guards/*` | 移動 | 純路由守衛歸 UI 層 |
| 認證服務 | `security/authentication/services/*` | `infrastructure/security/*` 或 `application/*` | 重整/分拆 | 以自製 token/會話服務為中心 |
| Firebase 認證 | `infrastructure/persistence/firebase/firebase-auth.service.ts` | 保持 | 校正 | 對齊自製 token/會話策略 |
| 模組 | `modules/*` | Standalone 組件 + `provide*` | 退場/替換 | 僅保留必要聚合 |
| Material Wrappers | `shared/components/material/*` | `docs/playground` 或 `labs/*` | 遷移 | 僅保留實用且穩定者 |
| Refresh Token | `core/net/refresh-token.service.ts` | `infrastructure/security/*` | 移動 | 對應攔截器與 token 流程 |

## 作業步驟（每個 Phase 的共通流程）
1. 代碼搬遷（目錄/檔案移動、重命名）。
2. 執行匯入修正腳本：
   - 指令建議（Windows + pnpm）：
     - `pnpm add -D ts-morph tsx`
     - `pnpm tsx tools/scripts/rename-imports.ts`
3. 更新 `app.config.ts`、`app.routes.ts` 的 providers 與路由守衛引用。
4. 重新產生 `docs/0.TREE.md`：
   - `pnpm tsx tools/scripts/generate-tree.ts > docs/0.TREE.md`
5. 構建與測試：
   - `pnpm build`、`pnpm test`（若有 e2e：`pnpm e2e`）。
6. 驗收清單對照（各 Phase 驗收標準）。

## 風險與回滾
- 風險：匯入路徑破裂、攔截器順序錯誤、守衛注入循環、示範代碼遺漏引用。
- 緩解：
  - 小步驟、單 Phase 單 PR；
  - AST 自動修正匯入；
  - 在 `app.config.ts` 統一攔截器註冊以避免順序不一致。
- 回滾：
  - 使用 Git 將單 Phase PR revert；
  - 保持 `tools/scripts/*` 不動作，以確保回滾後仍可重新產生 `0.TREE.md`。

## 里程碑與交付
- M1（1–2 日）：Phase 0 完成，自動化腳本雛形與層級 README 放置規範。
- M2（1–2 日）：Phase 1 合併完成，HTTP 與守衛單一來源生效。
- M3（1–2 日）：Phase 2 認證流統一至 `@delon/auth`，UI 經由 Facade/UseCase。
- M4（1 日）：Phase 3 模組退場或最小化。
- M5（0.5–1 日）：Phase 4 Material Wrappers 外移。
- M6（0.5 日）：Phase 5 `core` 邊界調整完畢。

## 驗收總清單（全域）
- **一致性**：代碼層按 DDD 邊界歸屬正確 [[memory:5079044]]。
- **認證統一**：僅有「自製 token/會話服務」為單一真實來源。
- **單一來源**：路由守衛僅在 `interface/guards`，HTTP 攔截器僅在 `infrastructure/interceptors`。
- **Standalone**：`modules/` 非必要依賴。
- **文件對齊**：`docs/0.TREE.md` 由腳本生成，與實際檔案一致。

