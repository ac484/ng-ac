## 1.security_plan — 守衛統一 / 攔截器統一 / 認證·授權收斂（實現計畫）

### 目標
- 將路由守衛集中於 `src/app/interface/guards`。
- 將 HTTP 攔截器集中於 `src/app/infrastructure/interceptors` 並統一由 `app.config.ts` 註冊。
- 收斂認證/授權為極簡、可測試的結構：`infrastructure/security` 提供 token 發放/存取/刷新 能力，`application/use-cases` 協作流程，`domain/services` 定義規則。
 - 定義最小「角色×權限矩陣」，由 Domain 單一來源提供規則校驗。
 - 提供最小「攔截監控」：請求耗時、狀態碼計數，避免引入額外依賴。
  - 與 Firebase Auth 對接取得/刷新 ID Token；與 Firestore 對接取得彈性角色與權限集合。

### 原則（極簡主義）
- 只做當前需要的功能；避免過早抽象與過度封裝。
- 移動而非重寫；保留現有 API 形式，降低風險。
- 單一來源：守衛/攔截器/認證流各自僅有一個來源位置。
- 每次提交保持可構建；頂部檔頭註解與日期即時更新。

### 範圍
- `src/app/interface/guards/*`
- `src/app/infrastructure/interceptors/*`
- `src/app/infrastructure/security/*`
- `src/app/app.config.ts`, `src/app/app.routes.ts`
- 既有 `core/*`、`modules/*` 退場（已完成）

### 資料夾結構（更明確，極簡版）
```text
src/
  app/
    app.config.ts
    app.routes.ts

    interface/
      guards/
        index.ts
        auth.guard.ts            # 檢查登入（依賴 UseCase/Facade）
        permission.guard.ts      # 權限點檢查（依賴 Domain 規則）
        role.guard.ts            # 角色檢查（依賴 Domain 規則）

    infrastructure/
      interceptors/
        auth-http.interceptor.ts # 附掛 Authorization、處理 401/403、必要時刷新
        error.interceptor.ts
        logging.interceptor.ts
      security/
        token.service.ts         # Firebase Auth 對接：issue/getIdToken/clear（單一來源）
        rbac.service.ts          # Firestore 對接：讀取使用者角色/權限（最小快取）
        refresh-token.service.ts # 專責刷新邏輯（由攔截器呼叫）

    application/
      services/
        auth.facade.ts           # Facade：UI/守衛唯一入口（組合 token + rbac）
      use-cases/
        login.use-case.ts        # 協作登入流程（可由 Facade 轉調）

    domain/
      services/
        auth.domain.service.ts   # 授權規則（無框架依賴；內含最小角色×權限矩陣）
```

### 檔案職責（最小而清晰）
- `interface/guards/*`：僅判斷路由通行；不直接操作 token。
- `infrastructure/interceptors/auth-http.interceptor.ts`：
  - 附掛 `Authorization: Bearer <token>`（由 `token.service` 提供）。
  - 401/403 → 嘗試 `refresh-token.service.refresh()`，成功重試一次，失敗清除 token 並導向登入。
- `infrastructure/security/token.service.ts`：
  - `issue(credentials)`：透過 Firebase Auth（`signInWithEmailAndPassword` 或現有登入流程）取得使用者；
  - `getIdToken(forceRefresh?: boolean)`：包裝 AngularFireAuth 的 `getIdToken`；
  - `clear()`：`signOut` 並清空本地緩存（如有）。
- `infrastructure/security/refresh-token.service.ts`：
  - `refresh()`：呼叫 `token.service.getIdToken(true)` 強制刷新，回傳新 token。
 - `infrastructure/security/rbac.service.ts`：
  - 從 Firestore 讀取使用者的動態角色與權限：
    - 方案 A（最小）：`users/{uid}` 文檔含 `roles: string[]`；`roles/{roleId}` 文檔含 `permissions: string[]`；
    - 權限計算：合併使用者直接權限（如 `users.permissions?`）與角色展開後的 `permissions` 去重；
  - 提供 `getUserRoles(uid)`、`getUserPermissions(uid)`，並做最小快取（記憶體）避免重取。
- `application/use-cases/login.use-case.ts`：協作登入流程，收斂 UI 與 infra。
- `domain/services/auth.domain.service.ts`：純規則（`hasPermission`、`hasRole`），並內建最小矩陣。
- `application/services/auth.facade.ts`：
  - `isAuthenticated()`、`hasRole(role)`、`hasPermission(perm)` 暴露給 UI/守衛；
  - 內部組合 `token.service`（Firebase Auth）與 `rbac.service`（Firestore）。

### 角色×權限矩陣（最小，可擴展）
- 單一來源：放在 `domain/services/auth.domain.service.ts` 內部常量（避免新增檔案）。
- 最小集合（可按需擴充）：
  - 角色：`admin`、`user`
  - 權限：`dashboard.view`、`user.list`
- 規則介面：
  - `hasRole(user, role)`：回傳布林
  - `hasPermission(user, permission)`：回傳布林（基於矩陣或使用者權限集合）
- UI/守衛使用：
  - `permission.guard.ts` / `role.guard.ts` 僅呼叫 Facade（Facade 內再委派 Domain 與 RBAC）。

### 攔截監控（最小，不引入新依賴）
- 實作位置：`infrastructure/interceptors/logging.interceptor.ts`。
- 內容：
  - 以 `performance.now()` 計時，輸出每次請求耗時（ms）與狀態碼至 `console`。
  - 失敗請求（4xx/5xx）輸出精簡錯誤摘要（URL、狀態碼、耗時）。
  - 可選：於 `auth-http.interceptor.ts` 附加 `X-Request-Id`（使用 `Date.now()` + 遞增序號，避免新增套件）。
- 驗收：
  - 構建後可觀察到請求/回應的耗時與狀態碼日誌。
  - 無第三方監控依賴；日後可換接 APM 僅改攔截器實作。

### 實作步驟
1) 守衛統一（Guards）
- 將所有路由守衛放在 `interface/guards/*`，供 `app.routes.ts` 以 `canActivate` 使用。
- 檢查路由內所有 `canActivate` 僅引用 `interface/guards`。
- 驗收：專案中無其他層級的守衛實作；僅有 `interface/guards/*`。

2) 攔截器統一（Interceptors）
- 將所有 HTTP 攔截器放在 `infrastructure/interceptors/*`。
- `app.config.ts` 使用 `provideHttpClient(withInterceptors([...]))` 集中註冊。
- 驗收：專案中攔截器僅由 `app.config.ts` 註冊；其他位置不再註冊攔截器。

3) 認證/授權收斂（Auth）
- `infrastructure/security`：最小三件套（`token.service.ts` + `refresh-token.service.ts` + `rbac.service.ts`）。
- 攔截器整合：`auth-http.interceptor.ts` 取 `token.service.getIdToken()`；401/403 → `refresh-token.service.refresh()`。
- Facade：`auth.facade.ts` 封裝 `isAuthenticated/hasRole/hasPermission`，UI/守衛只依賴此。
- 驗收：
  - UI 不直接觸及 infra 細節；token 發放/存取/刷新與 RBAC 皆有唯一來源。
  - 更換後端或資料結構時，僅改 infra 層服務。

4) 角色×權限矩陣（Domain 單一來源）
- 在 `auth.domain.service.ts` 內定義最小矩陣常量與 `hasRole/hasPermission`。
- 守衛僅呼叫 Domain 規則；測試以此服務為核心。
- 驗收：矩陣單點維護，守衛與 UI 不持有規則副本。

5) 攔截監控（Logging Interceptor）
- 在 `logging.interceptor.ts` 實作計時與狀態碼日誌；必要時於 `auth-http.interceptor.ts` 附帶 `X-Request-Id`。
- 驗收：請求/回應日誌含耗時與狀態碼；錯誤請求有簡要錯誤摘要。

### 完成後結構樹（聚焦區域）
```text
src/
  app/
    app.config.ts              # provideHttpClient(withInterceptors([...]))
    app.routes.ts              # 路由 canActivate 僅引用 interface/guards

    infrastructure/
      interceptors/
        auth-http.interceptor.ts
        error.interceptor.ts
        logging.interceptor.ts
      security/
        token.service.ts
        rbac.service.ts
        refresh-token.service.ts

    interface/
      guards/
        index.ts
        auth.guard.ts
        permission.guard.ts
        role.guard.ts

    application/
      services/
        auth.facade.ts
```

### 驗收清單
- [x] `core/*`、`modules/*` 退場，`0.TREE.md` 已對齊實際檔案。
- [x] 守衛集中於 `interface/guards/*`，路由僅引用該處。
- [x] 攔截器集中於 `infrastructure/interceptors/*`，並由 `app.config.ts` 單點註冊。
- [x] 認證刷新服務位於 `infrastructure/security/*`；新增 `token.service.ts`（發放+存取）。可視需要再拆分。
- [ ] Domain 內建最小角色×權限矩陣，守衛只依賴 Domain 規則。
- [ ] Logging Interceptor 具請求耗時與狀態碼日誌；錯誤摘要精簡可用。
- [ ] RBAC 透過 Firestore 提供動態角色與權限（`rbac.service.ts`）。
- [ ] Facade 封裝 UI 入口，避免 `interface` 直接依賴 infra。

### 變更日誌
- 2025-08-17：建立計畫並同步現況；保留攔截器與 token 能力的最小實作骨架。
- 2025-08-17：補強 token 發放/管理清單與最小資料夾結構，避免重工。
 - 2025-08-17：加入最小角色×權限矩陣與攔截監控，維持單一來源與極簡責任。
- 2025-08-17：加上 Firebase Auth/Firestore 對接（token.service / rbac.service）與 Facade 入口，確保可實踐。


